// Generated by CoffeeScript 1.9.0
(function() {
  
// http://stackoverflow.com/questions/6902280/cross-browser-dom-ready
function bindReady(handler){
    var called = false
    function ready() {
        if (called) return
        called = true
        handler()
    }
    if ( document.addEventListener ) {
        document.addEventListener( "DOMContentLoaded", function(){
            ready()
        }, false )
    } else if ( document.attachEvent ) {
        if ( document.documentElement.doScroll && window == window.top ) {
            function tryScroll(){
                if (called) return
                if (!document.body) return
                try {
                    document.documentElement.doScroll("left")
                    ready()
                } catch(e) {
                    setTimeout(tryScroll, 0)
                }
            }
            tryScroll()
        }
        document.attachEvent("onreadystatechange", function(){
            if ( document.readyState === "complete" ) {
                ready()
            }
        })
    }
    if (window.addEventListener)
        window.addEventListener('load', ready, false)
    else if (window.attachEvent)
        window.attachEvent('onload', ready)
    /*  else  // use this 'else' statement for very old browsers :)
        window.onload=ready
    */
}
readyList = []
function onReady(handler) {
    if (!readyList.length) {
        bindReady(function() {
            for(var i=0; i<readyList.length; i++) {
                readyList[i]()
            }
        })
    }
    readyList.push(handler)
}
;
  var initScene;

  if (!THREE.Quaternion.prototype.setFromVectors) {
    THREE.Quaternion.prototype.setFromVectors = function(a, b) {
      var axis;
      axis = (new THREE.Vector3).crossVectors(a, b);
      this.set(axis.x, axis.y, axis.z, 1 + a.dot(b));
      this.normalize();
      return this;
    };
  }

  if (!THREE.Bone.prototype.positionFromWorld) {
    THREE.Bone.prototype.positionFromWorld = function(eye, target) {
      var angle, directionDotParentDirection;
      directionDotParentDirection = this.worldDirection.dot(this.parent.worldDirection);
      angle = Math.acos(directionDotParentDirection);
      this.worldAxis.crossVectors(this.parent.worldDirection, this.worldDirection).normalize();
      this.worldUp.set(0, 0, 0).add(this.parent.worldUp.clone().multiplyScalar(directionDotParentDirection)).add((new THREE.Vector3).crossVectors(this.worldAxis, this.parent.worldUp).multiplyScalar(Math.sin(angle))).add(this.worldAxis.clone().multiplyScalar(this.worldAxis.dot(this.parent.worldUp) * (1 - directionDotParentDirection))).normalize();
      this.matrix.lookAt(eye, target, this.worldUp);
      this.worldQuaternion.setFromRotationMatrix(this.matrix);
      this.quaternion.copy(this.parent.worldQuaternion).inverse().multiply(this.worldQuaternion);
      return this;
    };
  }

  initScene = function(element) {
    var pointLight, scope;
    scope = this;
    this.scene = new THREE.Scene();
    pointLight = new THREE.PointLight(0xFFffff);
    pointLight.position = new THREE.Vector3(-20, 10, 0);
    pointLight.lookAt(new THREE.Vector3(0, 0, 0));
    this.scene.add(pointLight);
    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
    this.camera.position.fromArray([0, 160, 400]);
    this.camera.lookAt(new THREE.Vector3(0, 0, 0));
    if (!this.renderer) {
      this.renderer = new THREE.WebGLRenderer({
        alpha: true
      });
      this.renderer.setClearColor(0x000000, 0);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.domElement.style.position = 'fixed';
      this.renderer.domElement.style.top = 0;
      this.renderer.domElement.style.left = 0;
      this.renderer.domElement.style.width = '100%';
      this.renderer.domElement.style.height = '100%';
      window.addEventListener('resize', function() {
        scope.camera.aspect = window.innerWidth / window.innerHeight;
        scope.camera.updateProjectionMatrix();
        scope.renderer.setSize(window.innerWidth, window.innerHeight);
        return scope.renderer.render(scope.scene, scope.camera);
      }, false);
    }
    scope.scene.add(scope.camera);
    return scope.renderer.render(scope.scene, scope.camera);
  };

  Leap.plugin('riggedHand', function(scope) {
    var addMesh, basicDotMesh, controller, createMesh, getMesh, removeMesh, spareMeshes, zeroVector;
    if (scope == null) {
      scope = {};
    }
    this.use('handHold');
    this.use('handEntry');
    this.use('versionCheck', {
      requiredProtocolVersion: 6
    });
    scope.positionScale || (scope.positionScale = 1);
    scope.initScene = initScene;
    controller = this;
    scope.Detector = Detector;
    if (scope['checkWebGL'] === void 0) {
      scope.checkWebGL = !scope.parent;
    }
    if (scope.checkWebGL) {
      if (!scope.Detector.webgl) {
        scope.Detector.addGetWebGLMessage();
        return;
      }
    }
    if (!scope.parent) {
      scope.initScene();
      scope.parent = scope.scene;
      onReady((function(_this) {
        return function() {
          return document.body.appendChild(scope.renderer.domElement);
        };
      })(this));
    }
    if (scope.renderFn === void 0) {
      scope.renderFn = function() {
        return scope.renderer.render(scope.scene, scope.camera);
      };
    }
    spareMeshes = {
      left: [],
      right: []
    };
    createMesh = function(JSON) {
      var data, handMesh, i;
      data = (new THREE.JSONLoader).parse(JSON);
      data.materials[0].skinning = true;
      data.materials[0].transparent = true;
      data.materials[0].opacity = 0.7;
      data.materials[0].emissive.setHex(0x888888);
      data.materials[0].vertexColors = THREE.VertexColors;
      data.materials[0].depthTest = true;
      Leap._.extend(data.materials[0], scope.materialOptions);
      Leap._.extend(data.geometry, scope.geometryOptions);
      handMesh = new THREE.SkinnedMesh(data.geometry, data.materials[0]);
      handMesh.positionRaw = new THREE.Vector3;
      handMesh.fingers = handMesh.children[0].children;
      handMesh.castShadow = true;
      handMesh.bonesBySkinIndex = {};
      i = 0;
      handMesh.children[0].traverse(function(bone) {
        bone.skinIndex = i;
        handMesh.bonesBySkinIndex[i] = bone;
        return i++;
      });
      handMesh.boneLabels = {};
      if (scope.boneLabels) {
        handMesh.traverse(function(bone) {
          var attribute, label, value, _base, _name, _ref, _results;
          label = (_base = handMesh.boneLabels)[_name = bone.id] || (_base[_name] = document.createElement('div'));
          label.style.position = 'absolute';
          label.style.zIndex = '10';
          label.style.color = 'white';
          label.style.fontSize = '20px';
          label.style.textShadow = '0px 0px 3px black';
          label.style.fontFamily = 'helvetica';
          label.style.textAlign = 'center';
          _ref = scope.labelAttributes;
          _results = [];
          for (attribute in _ref) {
            value = _ref[attribute];
            _results.push(label.setAttribute(attribute, value));
          }
          return _results;
        });
      }
      handMesh.screenPosition = function(position) {
        var camera, height, screenPosition, width;
        camera = scope.camera;
        console.assert(camera instanceof THREE.Camera, "screenPosition expects camera, got", camera);
        width = parseInt(window.getComputedStyle(scope.renderer.domElement).width, 10);
        height = parseInt(window.getComputedStyle(scope.renderer.domElement).height, 10);
        console.assert(width && height);
        screenPosition = new THREE.Vector3();
        if (position instanceof THREE.Vector3) {
          screenPosition.fromArray(position.toArray());
        } else {
          screenPosition.fromArray(position).sub(this.positionRaw).add(this.position);
        }
        screenPosition.project(camera);
        screenPosition.x = (screenPosition.x * width / 2) + width / 2;
        screenPosition.y = (screenPosition.y * height / 2) + height / 2;
        console.assert(!isNaN(screenPosition.x) && !isNaN(screenPosition.x), 'x/y screen position invalid');
        return screenPosition;
      };
      handMesh.scenePosition = function(leapPosition, scenePosition) {
        return scenePosition.fromArray(leapPosition).sub(handMesh.positionRaw).add(handMesh.position);
      };
      handMesh.scaleFromHand = function(leapHand) {
        var middleProximalLeapLength, middleProximalMeshLength;
        middleProximalLeapLength = (new THREE.Vector3).subVectors((new THREE.Vector3).fromArray(leapHand.fingers[2].pipPosition), (new THREE.Vector3).fromArray(leapHand.fingers[2].mcpPosition)).length();
        middleProximalMeshLength = handMesh.fingers[2].position.length();
        handMesh.leapScale = middleProximalLeapLength / middleProximalMeshLength;
        return handMesh.scale.set(handMesh.leapScale, handMesh.leapScale, handMesh.leapScale);
      };
      return handMesh;
    };
    getMesh = function(leapHand) {
      var JSON, handMesh, meshes;
      meshes = spareMeshes[leapHand.type];
      if (meshes.length > 0) {
        handMesh = meshes.pop();
      } else {
        JSON = rigs[leapHand.type];
        handMesh = createMesh(JSON);
      }
      return handMesh;
    };
    createMesh(rigs['right']);
    zeroVector = new THREE.Vector3(0, 0, 0);
    addMesh = function(leapHand) {
      var handMesh, palm, rigFinger, _i, _len, _ref;
      handMesh = getMesh(leapHand);
      scope.parent.add(handMesh);
      leapHand.data('riggedHand.mesh', handMesh);
      palm = handMesh.children[0];
      if (scope.helper) {
        handMesh.helper = new THREE.SkeletonHelper(handMesh);
        scope.parent.add(handMesh.helper);
      }
      palm.worldUp = new THREE.Vector3;
      palm.positionLeap = new THREE.Vector3;
      _ref = handMesh.fingers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rigFinger = _ref[_i];
        rigFinger.pip = rigFinger.children[0];
        rigFinger.dip = rigFinger.pip.children[0];
        rigFinger.tip = rigFinger.dip.children[0];
        rigFinger.worldQuaternion = new THREE.Quaternion;
        rigFinger.pip.worldQuaternion = new THREE.Quaternion;
        rigFinger.dip.worldQuaternion = new THREE.Quaternion;
        rigFinger.worldAxis = new THREE.Vector3;
        rigFinger.pip.worldAxis = new THREE.Vector3;
        rigFinger.dip.worldAxis = new THREE.Vector3;
        rigFinger.worldDirection = new THREE.Vector3;
        rigFinger.pip.worldDirection = new THREE.Vector3;
        rigFinger.dip.worldDirection = new THREE.Vector3;
        rigFinger.worldUp = new THREE.Vector3;
        rigFinger.pip.worldUp = new THREE.Vector3;
        rigFinger.dip.worldUp = new THREE.Vector3;
        rigFinger.positionLeap = new THREE.Vector3;
        rigFinger.pip.positionLeap = new THREE.Vector3;
        rigFinger.dip.positionLeap = new THREE.Vector3;
        rigFinger.tip.positionLeap = new THREE.Vector3;
      }
      palm.worldDirection = new THREE.Vector3;
      palm.worldQuaternion = handMesh.quaternion;
      if (scope.boneLabels) {
        handMesh.children[0].traverse(function(bone) {
          return document.body.appendChild(handMesh.boneLabels[bone.id]);
        });
      }
      return controller.emit('riggedHand.meshAdded', handMesh, leapHand);
    };
    removeMesh = function(leapHand) {
      var handMesh;
      handMesh = leapHand.data('riggedHand.mesh');
      leapHand.data('riggedHand.mesh', null);
      scope.parent.remove(handMesh);
      if (handMesh.helper) {
        scope.parent.remove(handMesh.helper);
        handMesh.helper = null;
      }
      spareMeshes[leapHand.type].push(handMesh);
      if (scope.boneLabels) {
        handMesh.children[0].traverse(function(bone) {
          return document.body.removeChild(handMesh.boneLabels[bone.id]);
        });
      }
      controller.emit('riggedHand.meshRemoved', handMesh, leapHand);
      if (scope.renderFn) {
        return scope.renderFn();
      }
    };
    scope.dots = {};
    basicDotMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 1), new THREE.MeshNormalMaterial());
    scope.positionDots = function(leapHand, handMesh) {
      var i, leapFinger, point, _i, _len, _ref, _results;
      if (!scope.dotsMode) {
        return;
      }
      if (!scope.dots["palmPosition"]) {
        scope.dots["palmPosition"] = new THREE.Mesh(new THREE.IcosahedronGeometry(4, 1), new THREE.MeshNormalMaterial());
        scope.parent.add(scope.dots["palmPosition"]);
      }
      handMesh.scenePosition(leapHand["palmPosition"], scope.dots["palmPosition"].position);
      _ref = leapHand.fingers;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        leapFinger = _ref[i];
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = ['carp', 'mcp', 'pip', 'dip', 'tip'];
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            point = _ref1[_j];
            if (!scope.dots[point + "-" + i]) {
              scope.dots[point + "-" + i] = basicDotMesh.clone();
              scope.parent.add(scope.dots[point + "-" + i]);
            }
            _results1.push(handMesh.scenePosition(leapFinger[point + "Position"], scope.dots[point + "-" + i].position));
          }
          return _results1;
        })());
      }
      return _results;
    };
    this.on('handFound', addMesh);
    this.on('handLost', removeMesh);
    return {
      frame: function(frame) {
        var boneColors, face, faceIndices, geometry, handMesh, hue, i, j, leapHand, lightness, mcp, palm, saturation, weights, xBoneHSL, yBoneHSL, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _name, _name1, _ref, _ref1, _ref2, _ref3;
        if (scope.stats) {
          scope.stats.begin();
        }
        _ref = frame.hands;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          leapHand = _ref[_i];
          leapHand.fingers = Leap._.sortBy(leapHand.fingers, function(finger) {
            return finger.id;
          });
          handMesh = leapHand.data('riggedHand.mesh');
          palm = handMesh.children[0];
          handMesh.scaleFromHand(leapHand);
          palm.positionLeap.fromArray(leapHand.palmPosition);
          _ref1 = palm.children;
          for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
            mcp = _ref1[i];
            mcp.positionLeap.fromArray(leapHand.fingers[i].mcpPosition);
            mcp.pip.positionLeap.fromArray(leapHand.fingers[i].pipPosition);
            mcp.dip.positionLeap.fromArray(leapHand.fingers[i].dipPosition);
            mcp.tip.positionLeap.fromArray(leapHand.fingers[i].tipPosition);
          }
          palm.worldDirection.fromArray(leapHand.direction);
          palm.up.fromArray(leapHand.palmNormal).multiplyScalar(-1);
          palm.worldUp.fromArray(leapHand.palmNormal).multiplyScalar(-1);
          handMesh.positionRaw.fromArray(leapHand.palmPosition);
          handMesh.position.copy(handMesh.positionRaw).multiplyScalar(scope.positionScale);
          handMesh.matrix.lookAt(palm.worldDirection, zeroVector, palm.up);
          palm.worldQuaternion.setFromRotationMatrix(handMesh.matrix);
          _ref2 = palm.children;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            mcp = _ref2[_k];
            mcp.traverse(function(bone) {
              if (bone.children[0]) {
                bone.worldDirection.subVectors(bone.children[0].positionLeap, bone.positionLeap).normalize();
                return bone.positionFromWorld(bone.children[0].positionLeap, bone.positionLeap);
              }
            });
          }
          if (handMesh.helper) {
            handMesh.helper.update();
          }
          scope.positionDots(leapHand, handMesh);
          if (scope.boneLabels) {
            palm.traverse(function(bone) {
              var element, screenPosition;
              if (element = handMesh.boneLabels[bone.id]) {
                screenPosition = handMesh.screenPosition(bone.positionLeap, scope.camera);
                element.style.left = screenPosition.x + "px";
                element.style.bottom = screenPosition.y + "px";
                return element.innerHTML = scope.boneLabels(bone, leapHand) || '';
              }
            });
          }
          if (scope.boneColors) {
            geometry = handMesh.geometry;
            boneColors = {};
            i = 0;
            while (i < geometry.vertices.length) {
              boneColors[_name = geometry.skinIndices[i].x] || (boneColors[_name] = scope.boneColors(handMesh.bonesBySkinIndex[geometry.skinIndices[i].x], leapHand) || {
                hue: 0,
                saturation: 0
              });
              boneColors[_name1 = geometry.skinIndices[i].y] || (boneColors[_name1] = scope.boneColors(handMesh.bonesBySkinIndex[geometry.skinIndices[i].y], leapHand) || {
                hue: 0,
                saturation: 0
              });
              xBoneHSL = boneColors[geometry.skinIndices[i].x];
              yBoneHSL = boneColors[geometry.skinIndices[i].y];
              weights = geometry.skinWeights[i];
              hue = xBoneHSL.hue || yBoneHSL.hue;
              lightness = xBoneHSL.lightness || yBoneHSL.lightness || 0.5;
              saturation = xBoneHSL.saturation * weights.x + yBoneHSL.saturation * weights.y;
              (_base = geometry.colors)[i] || (_base[i] = new THREE.Color());
              geometry.colors[i].setHSL(hue, saturation, lightness);
              i++;
            }
            geometry.colorsNeedUpdate = true;
            faceIndices = 'abc';
            _ref3 = geometry.faces;
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              face = _ref3[_l];
              j = 0;
              while (j < 3) {
                face.vertexColors[j] = geometry.colors[face[faceIndices[j]]];
                j++;
              }
            }
          }
        }
        if (scope.renderFn) {
          scope.renderFn();
        }
        if (scope.stats) {
          return scope.stats.end();
        }
      }
    };
  });

}).call(this);
